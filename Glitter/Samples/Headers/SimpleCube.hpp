#ifndef SIMPLE_CUBE
#define SIMPLE_CUBE

#include "glitter.hpp"
#include "Shader.h"
#include "BaseSample.hpp"

const glm::vec3 cubePositions[] = {
	glm::vec3(0.0f,  0.0f,  0.0f),
	glm::vec3(2.0f,  5.0f, -15.0f),
	glm::vec3(-1.5f, -2.2f, -2.5f),
	glm::vec3(-3.8f, -2.0f, -12.3f),
	glm::vec3(2.4f, -0.4f, -3.5f),
	glm::vec3(-1.7f,  3.0f, -7.5f),
	glm::vec3(1.3f, -2.0f, -2.5f),
	glm::vec3(1.5f,  2.0f, -2.5f),
	glm::vec3(1.5f,  0.2f, -1.5f),
	glm::vec3(-1.3f,  1.0f, -1.5f)
};

class Sample_CubeRender : public BaseSample
{
private:
	unsigned int VBO;
	unsigned int VAO;
	unsigned int texture1, texture2;
	Shader *_renderShader;
public:
	bool setup(int argc, char * argv[]) override
	{
		glGenVertexArrays(1, &VAO);
		glGenBuffers(1, &VBO);
		glBindVertexArray(VAO);
		glBindBuffer(GL_ARRAY_BUFFER, VBO);
		glBufferData(GL_ARRAY_BUFFER, sizeof(GlitterConfig::data_cube_vertices), GlitterConfig::data_cube_vertices, GL_STATIC_DRAW);

		//  3 attributes(position , color, texture coord)
		// sizeof 8 float [0,0,0|0,0,0|0,0]
		// input vertex layout
		// position attribute
		glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);
		glEnableVertexAttribArray(0);

		// vertex color attribute
		glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));
		glEnableVertexAttribArray(1);

		// texture coord attribute
		glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));
		glEnableVertexAttribArray(2);

		// init shader
		std::string path = GlitterConfig::path_res_shader;
		std::string vspath = path + "simple.vert";
		std::string fspath = path + "simple.frag";
		_renderShader = new Shader(vspath.c_str(), fspath.c_str());

		std::string texture1path = GlitterConfig::path_res_textures + "container.jpg";
		std::string texture2path = GlitterConfig::path_res_textures + "awesomeface.png";

		glGenTextures(1, &texture1);
		glBindTexture(GL_TEXTURE_2D, texture1);

		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
		// set texture filtering parameters
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

		int width, height, nrChannels;
		stbi_set_flip_vertically_on_load(true); // tell stb_image.h to flip loaded texture's on the y-axis.
		unsigned char *data = stbi_load(texture1path.c_str(), &width, &height, &nrChannels, 0);
		if (data)
		{
			std::cout << "Load Texture Success." << std::endl;
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
			glGenerateMipmap(GL_TEXTURE_2D);
		}
		else
		{
			std::cout << "Failed to load texture" << std::endl;
		}
		stbi_image_free(data);

		// texture 2
		// ---------
		glGenTextures(1, &texture2);
		glBindTexture(GL_TEXTURE_2D, texture2);
		// set the texture wrapping parameters
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
		// set texture filtering parameters
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		// load image, create texture and generate mipmaps
		data = stbi_load(texture2path.c_str(), &width, &height, &nrChannels, 0);
		if (data)
		{
			// note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA
			std::cout << "Load Texture Success." << std::endl;
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
			glGenerateMipmap(GL_TEXTURE_2D);
		}
		else
		{
			std::cout << "Failed to load texture" << std::endl;
		}
		stbi_image_free(data);

		// set texture samples
		_renderShader->use();
		_renderShader->setInt("texture1", 0);
		_renderShader->setInt("texture2", 1);
		return true;
	}

	void render(SimpleCamera& camera, float time) override
	{
		// bind textures on corresponding texture units
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture1);
		glActiveTexture(GL_TEXTURE1);
		glBindTexture(GL_TEXTURE_2D, texture2);

		_renderShader->use();

		// view/projection transformations
		glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)mWidth / (float)mHeight, 0.1f, 100.0f);
		glm::mat4 view = camera.GetViewMatrix();
		_renderShader->setMat4("projection", projection);
		_renderShader->setMat4("view", view);

		RenderCubeSample();
	}

	bool shutdown() override
	{
		delete _renderShader;
		_renderShader = NULL;
		glDeleteVertexArrays(1, &VAO);
		glDeleteBuffers(1, &VBO);
		return true;
	}

public:
	Sample_CubeRender() :BaseSample("Simple Cube Render")
	{
	}
private:
	void RenderCubeSample()
	{
		int renderindex = 0;
		glBindVertexArray(VAO);
		for (glm::vec3 item : cubePositions)
		{
			renderindex++;
			float angle = 20.0f * renderindex;
			glm::mat4 model = glm::mat4(1.0f);
			model = glm::translate(model, item);
			model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f));
			_renderShader->setMat4("model", model);
			glDrawArrays(GL_TRIANGLES, 0, 36);
		}
	}
};
#endif // ! SIMPLE_CUBE
